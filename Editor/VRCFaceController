using UnityEngine;
using UnityEditor;
using UnityEditor.Animations;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace VRCFaceController
{
    public class VRCFaceController : EditorWindow
    {
        private AnimatorController targetController;
        private Vector2 scrollPosition;
        private Vector2 gestureScrollPosition;
        private Vector2 animScrollPosition;
        
        // タブ管理
        private int selectedTab = 0;
        private readonly string[] tabNames = { "パラメータエディタ", "アニメーション置換", "設定" };

        // パラメータ関連
        private List<string> availableParameters = new List<string>();
        private string selectedParameter = "";
        private Dictionary<string, float> parameterValues = new Dictionary<string, float>();
        
        // 選択中の値
        private List<int> selectedValues = new List<int>() { 0, 1, 2, 3 };
        private List<string> valueLabels = new List<string>() { "値=0", "値=1", "値=2", "値=3" };
        private int currentValueIndex = 0;

        // レイヤー選択
        private string[] layerNames = new string[0];
        private int selectedLayerIndex = -1;

        // ハンドジェスチャー名
        private static readonly string[] GestureNames = new string[] {
            "ニュートラル", "グー", "指差し", "ピース",
            "パー", "ロック", "指OK", "銃"
        };

        // パラメータ解析用
        private Dictionary<string, List<ParameterDriverState>> gestureParameterMap = new Dictionary<string, List<ParameterDriverState>>();
        private List<AnimationClip> controllerClips = new List<AnimationClip>();
        private Dictionary<AnimationClip, AnimationClip> animationReplacementMap = new Dictionary<AnimationClip, AnimationClip>();
        
        // 出力設定
        private string outputFolder = "Assets/VRCFaceController/Export";
        private string outputPrefix = "VRC_";
        private bool copyController = true;
        
        // 表示オプション
        private float gestureDisplayHeight = 600f; // ジェスチャー表示領域の高さ
        
        // スタイル
        private GUIStyle headerStyle;
        private GUIStyle cellStyle;
        private GUIStyle enabledStyle;
        private GUIStyle disabledStyle;
        private GUIStyle separatorStyle;
        private GUIStyle dropAreaStyle;
        private GUIStyle dropAreaTextStyle;
        private GUIStyle boldFoldoutStyle;
        private GUIStyle thinSeparatorStyle;

        // デバッグ情報
        private bool showDebugInfo = false;
        private string debugMessage = "";

        // VRChatのコンポーネント名（SDK非依存の実装）
        private const string VRCParameterDriverTypeName = "VRC.SDK3.Avatars.Components.VRCAvatarParameterDriver";
        private const string ModularAvatarDriverTypeName = "nadena.dev.modular_avatar.core.ParameterSyncStep";

        [MenuItem("VRC Tools/VRC Avatar Parameter Driver Editor")]
        public static void ShowWindow()
        {
            GetWindow<VRCFaceController>("VRC パラメータエディタ");
        }

        private void OnEnable()
        {
            InitializeStyles();
            
            // デフォルトでジェスチャーマップを初期化
            gestureParameterMap["GestureLeft"] = new List<ParameterDriverState>();
            gestureParameterMap["GestureRight"] = new List<ParameterDriverState>();
        }

        private void InitializeStyles()
        {
            headerStyle = new GUIStyle(EditorStyles.boldLabel);
            headerStyle.alignment = TextAnchor.MiddleCenter;
            headerStyle.fontSize = 12;
            
            cellStyle = new GUIStyle(EditorStyles.label);
            cellStyle.alignment = TextAnchor.MiddleLeft;
            cellStyle.padding = new RectOffset(5, 5, 3, 3);
            
            enabledStyle = new GUIStyle(EditorStyles.miniButton);
            enabledStyle.normal.background = CreateColorTexture(new Color(0.2f, 0.7f, 0.3f, 0.5f));
            enabledStyle.hover.background = CreateColorTexture(new Color(0.3f, 0.8f, 0.4f, 0.7f));
            
            disabledStyle = new GUIStyle(EditorStyles.miniButton);
            disabledStyle.normal.background = CreateColorTexture(new Color(0.7f, 0.2f, 0.2f, 0.5f));
            disabledStyle.hover.background = CreateColorTexture(new Color(0.8f, 0.3f, 0.3f, 0.7f));
            
            separatorStyle = new GUIStyle();
            separatorStyle.normal.background = EditorGUIUtility.whiteTexture;
            separatorStyle.margin = new RectOffset(0, 0, 4, 4);
            separatorStyle.fixedHeight = 1;
            
            // ドロップエリア用スタイル
            dropAreaStyle = new GUIStyle();
            dropAreaStyle.normal.background = CreateColorTexture(new Color(0.5f, 0.5f, 0.5f, 0.2f));
            dropAreaStyle.border = new RectOffset(3, 3, 3, 3);
            dropAreaStyle.margin = new RectOffset(5, 5, 8, 8);
            dropAreaStyle.padding = new RectOffset(5, 5, 5, 5);
            dropAreaStyle.alignment = TextAnchor.MiddleCenter;
            
            dropAreaTextStyle = new GUIStyle(EditorStyles.boldLabel);
            dropAreaTextStyle.normal.textColor = EditorGUIUtility.isProSkin ? Color.white : Color.black;
            dropAreaTextStyle.alignment = TextAnchor.MiddleCenter;
            dropAreaTextStyle.fontSize = 12;
            
            boldFoldoutStyle = new GUIStyle(EditorStyles.foldout);
            boldFoldoutStyle.fontStyle = FontStyle.Bold;
            
            thinSeparatorStyle = new GUIStyle();
            thinSeparatorStyle.normal.background = EditorGUIUtility.whiteTexture;
            thinSeparatorStyle.margin = new RectOffset(0, 0, 2, 2);
            thinSeparatorStyle.fixedHeight = 1;
        }

        private void OnGUI()
        {
            EditorGUILayout.BeginVertical();
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
            
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label("VRC Avatar Parameter Driver エディタ", EditorStyles.boldLabel);
            GUILayout.FlexibleSpace();
            
            // デバッグボタン
            if (GUILayout.Button("デバッグ情報", GUILayout.Width(80)))
            {
                showDebugInfo = !showDebugInfo;
                if (showDebugInfo)
                {
                    UpdateDebugInfo();
                }
            }
            EditorGUILayout.EndHorizontal();
            
            DrawThinSeparator();

            DrawControllerSelectionArea();

            if (targetController == null)
            {
                EditorGUILayout.HelpBox("アニメーターコントローラを選択してください。", MessageType.Info);
                EditorGUILayout.EndScrollView();
                EditorGUILayout.EndVertical();
                return;
            }

            // デバッグ情報の印字
            if (showDebugInfo)
            {
                EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                EditorGUILayout.LabelField("デバッグ情報", EditorStyles.boldLabel);
                EditorGUILayout.LabelField($"選択中パラメータ: {selectedParameter}");
                EditorGUILayout.LabelField($"選択中値インデックス: {currentValueIndex}");
                if (selectedValues.Count > 0 && currentValueIndex < selectedValues.Count)
                {
                    EditorGUILayout.LabelField($"選択中値: {selectedValues[currentValueIndex]}");
                }
                EditorGUILayout.LabelField($"値のリスト: {string.Join(", ", selectedValues)}");
                EditorGUILayout.EndVertical();
            }

            // タブ切り替え
            selectedTab = GUILayout.Toolbar(selectedTab, tabNames);
            
            EditorGUILayout.Space();
            
            switch (selectedTab)
            {
                case 0: // パラメータエディタ
                    DrawParameterEditorTab();
                    break;
                case 1: // アニメーション置換
                    DrawAnimationReplaceTab();
                    break;
                case 2: // 設定
                    DrawSettingsTab();
                    break;
            }
            
            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        private void DrawThinSeparator()
        {
            Color color = EditorGUIUtility.isProSkin ? new Color(0.5f, 0.5f, 0.5f, 1.0f) : new Color(0.3f, 0.3f, 0.3f, 1.0f);
            
            Rect rect = GUILayoutUtility.GetRect(GUIContent.none, thinSeparatorStyle);
            if (Event.current.type == EventType.Repaint)
            {
                Color old = GUI.color;
                GUI.color = color;
                thinSeparatorStyle.Draw(rect, false, false, false, false);
                GUI.color = old;
            }
        }

        #region タブ1: パラメータエディタ

        private void DrawParameterEditorTab()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            EditorGUILayout.LabelField("パラメータ選択", EditorStyles.boldLabel);
            
            // レイヤー選択
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("レイヤー:", GUILayout.Width(70));
            
            // レイヤー選択用のオプション配列を作成（「すべて」を追加）
            string[] layerOptions = new string[layerNames.Length + 1];
            layerOptions[0] = "すべて";
            for (int i = 0; i < layerNames.Length; i++)
            {
                layerOptions[i + 1] = layerNames[i];
            }
            
            int displayLayerIndex = selectedLayerIndex + 1; // -1 → 0 (すべて)
            
            EditorGUI.BeginChangeCheck();
            displayLayerIndex = EditorGUILayout.Popup(displayLayerIndex, layerOptions, GUILayout.Width(200));
            if (EditorGUI.EndChangeCheck())
            {
                // 表示インデックスから内部インデックスに変換
                selectedLayerIndex = displayLayerIndex - 1;
                // レイヤーが変更されたら再解析
                AnalyzeController();
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("コントロールパラメータ:", GUILayout.Width(130));
            
            // 「なし」を含むパラメータリストを作成
            List<string> paramOptions = new List<string>();
            paramOptions.Add("なし");
            paramOptions.AddRange(availableParameters);
            
            // 現在の選択を取得
            int paramIndex = string.IsNullOrEmpty(selectedParameter) ? 0 : paramOptions.IndexOf(selectedParameter);
            if (paramIndex < 0) paramIndex = 0;
            
            EditorGUI.BeginChangeCheck();
            paramIndex = EditorGUILayout.Popup(paramIndex, paramOptions.ToArray(), GUILayout.Width(150));
            if (EditorGUI.EndChangeCheck())
            {
                selectedParameter = paramIndex == 0 ? "" : paramOptions[paramIndex];
                
                // 選択パラメータ変更時に値の設定を更新
                UpdateParameterValueOptions();
                
                // 再解析
                AnalyzeController();
            }
            
            // パラメータが選択されている場合のみ値を表示
            if (!string.IsNullOrEmpty(selectedParameter))
            {
                // 値の選択
                EditorGUILayout.LabelField("値:", GUILayout.Width(30));
                EditorGUI.BeginChangeCheck();
                if (valueLabels.Count > 0)
                {
                    currentValueIndex = EditorGUILayout.Popup(currentValueIndex, valueLabels.ToArray(), GUILayout.Width(150));
                    if (EditorGUI.EndChangeCheck())
                    {
                        // 再解析
                        AnalyzeController();
                    }
                }
                else
                {
                    EditorGUILayout.LabelField("値が見つかりません", GUILayout.Width(150));
                }
            }
            
            EditorGUILayout.EndHorizontal();

            // 表示領域の高さ設定
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("表示領域の高さ:", GUILayout.Width(100));
            gestureDisplayHeight = EditorGUILayout.Slider(gestureDisplayHeight, 300f, 1000f);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.EndVertical();
            
            // デバッグ情報の印字
            if (showDebugInfo)
            {
                EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                EditorGUILayout.LabelField("デバッグ情報", EditorStyles.boldLabel);
                EditorGUILayout.LabelField($"選択中パラメータ: {selectedParameter}");
                EditorGUILayout.LabelField($"選択中値インデックス: {currentValueIndex}");
                if (selectedValues.Count > 0 && currentValueIndex < selectedValues.Count)
                {
                    EditorGUILayout.LabelField($"選択中値: {selectedValues[currentValueIndex]}");
                }
                EditorGUILayout.LabelField($"値のリスト: {string.Join(", ", selectedValues)}");
                EditorGUILayout.EndVertical();
            }
            
            DrawThinSeparator();
            
            // 左右のジェスチャー表示（統合スクロールビュー）
            gestureScrollPosition = EditorGUILayout.BeginScrollView(gestureScrollPosition, GUILayout.Height(gestureDisplayHeight));
            
            EditorGUILayout.BeginHorizontal();
            
            // 左側 - 左手ジェスチャー
            EditorGUILayout.BeginVertical(EditorStyles.helpBox, GUILayout.Width(position.width/2 - 20));
            GUILayout.Label("左手ジェスチャー (GestureLeft)", headerStyle);
            DrawGestureSection("GestureLeft");
            EditorGUILayout.EndVertical();
            
            // 右側 - 右手ジェスチャー
            EditorGUILayout.BeginVertical(EditorStyles.helpBox, GUILayout.Width(position.width/2 - 20));
            GUILayout.Label("右手ジェスチャー (GestureRight)", headerStyle);
            DrawGestureSection("GestureRight");
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.EndScrollView();
            
            EditorGUILayout.Space();
            
            // アクションボタン
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("変更を保存", GUILayout.Height(30)))
            {
                SaveAsset();
            }
            
            EditorGUILayout.EndHorizontal();
        }

        private void DrawGestureSection(string gestureType)
        {
            if (!gestureParameterMap.ContainsKey(gestureType) || gestureParameterMap[gestureType].Count == 0)
            {
                if (targetController != null)
                {
                    EditorGUILayout.HelpBox("パラメータが見つかりませんでした。", MessageType.Info);
                    
                    if (GUILayout.Button("トランジションからジェスチャーステートを検索"))
                    {
                        DetectGestureTransitions(gestureType);
                    }
                }
                return;
            }
            
            var stateList = gestureParameterMap[gestureType];
            
            // ジェスチャー値ごとに表示を分割
            // ニュートラル（0）は表示しない
            int startGesture = 1;
            
            Dictionary<int, List<ParameterDriverState>> groupedByGesture = new Dictionary<int, List<ParameterDriverState>>();
            
            // ジェスチャー値ごとにグループ化
            for (int i = 0; i < 8; i++)
            {
                groupedByGesture[i] = new List<ParameterDriverState>();
            }
            
            foreach (var state in stateList)
            {
                if (state.gestureValue >= 0 && state.gestureValue < 8)
                {
                    groupedByGesture[state.gestureValue].Add(state);
                }
            }
            
            // ジェスチャー値ごとに表示
            for (int gestureValue = startGesture; gestureValue < 8; gestureValue++)
            {
                var filteredParams = groupedByGesture[gestureValue];
                if (filteredParams.Count == 0)
                {
                    continue;
                }
                
                EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                
                // ジェスチャー名
                EditorGUILayout.BeginHorizontal();
                GUILayout.Label($"{gestureValue}: {GestureNames[gestureValue]}", EditorStyles.boldLabel);
                EditorGUILayout.EndHorizontal();
                
                // パラメータの追加ボタン
                if (GUILayout.Button("パラメータを追加", EditorStyles.miniButton))
                {
                    ShowAddParameterMenu(gestureType, gestureValue);
                }
                
                // パラメータリストを統合して表示
                // パラメータ名でグループ化（同じパラメータを複数回表示しない）
                var distinctParams = new Dictionary<string, ParameterDriverState>();
                
                foreach (var paramState in filteredParams)
                {
                    if (!distinctParams.ContainsKey(paramState.parameterName))
                    {
                        distinctParams[paramState.parameterName] = paramState;
                    }
                }
                
                // 各パラメータを表示
                foreach (var paramState in distinctParams.Values)
                {
                    DrawParameterToggle(paramState);
                }
                
                EditorGUILayout.EndVertical();
                EditorGUILayout.Space(5);
            }
        }
        
        private void DetectGestureTransitions(string gestureType)
        {
            int foundCount = 0;
            
            foreach (var layer in targetController.layers)
            {
                if (layer.stateMachine != null)
                {
                    foundCount += ExtensiveSearchForGestureTransitions(layer.stateMachine, layer.name, gestureType);
                }
            }
            
            if (foundCount > 0)
            {
                EditorUtility.DisplayDialog("検索完了", $"{foundCount}個のパラメータを見つけました。", "OK");
            }
            else
            {
                EditorUtility.DisplayDialog("検索結果", $"{gestureType}のステートが見つかりませんでした。", "OK");
            }
        }

        private int ExtensiveSearchForGestureTransitions(AnimatorStateMachine stateMachine, string layerPath, string gestureType)
        {
            int foundCount = 0;
            Dictionary<int, List<AnimatorState>> gestureValueToStatesMap = new Dictionary<int, List<AnimatorState>>();
            
            // 0～7のすべてのジェスチャー値に対して空のリストを初期化
            for (int i = 0; i < 8; i++)
            {
                gestureValueToStatesMap[i] = new List<AnimatorState>();
            }
            
            // AnyStateからの遷移を検索（優先）
            foreach (var transition in stateMachine.anyStateTransitions)
            {
                if (transition.destinationState == null) continue;
                
                bool hasGestureCondition = false;
                int gestureValue = -1;
                
                foreach (var condition in transition.conditions)
                {
                    if (condition.parameter == gestureType)
                    {
                        hasGestureCondition = true;
                        gestureValue = Mathf.RoundToInt(condition.threshold);
                        break;
                    }
                }
                
                if (hasGestureCondition && gestureValue >= 0 && gestureValue <= 7)
                {
                    // コントロールパラメータのフィルタリング
                    bool matchesControlParam = true;
                    if (!string.IsNullOrEmpty(selectedParameter) && selectedValues.Count > currentValueIndex)
                    {
                        matchesControlParam = false;
                        int targetValue = selectedValues[currentValueIndex];
                        
                        foreach (var condition in transition.conditions)
                        {
                            if (condition.parameter == selectedParameter && 
                                Mathf.RoundToInt(condition.threshold) == targetValue)
                            {
                                matchesControlParam = true;
                                break;
                            }
                        }
                    }
                    
                    if (matchesControlParam)
                    {
                        gestureValueToStatesMap[gestureValue].Add(transition.destinationState);
                    }
                }
            }
            
            // エントリーステートからの遷移を検索
            if (stateMachine.defaultState != null)
            {
                foreach (var transition in stateMachine.defaultState.transitions)
                {
                    if (transition.destinationState == null) continue;
                    
                    bool hasGestureCondition = false;
                    int gestureValue = -1;
                    
                    foreach (var condition in transition.conditions)
                    {
                        if (condition.parameter == gestureType)
                        {
                            hasGestureCondition = true;
                            gestureValue = Mathf.RoundToInt(condition.threshold);
                            break;
                        }
                    }
                    
                    if (hasGestureCondition && gestureValue >= 0 && gestureValue <= 7)
                    {
                        // コントロールパラメータのフィルタリング
                        bool matchesControlParam = true;
                        if (!string.IsNullOrEmpty(selectedParameter) && selectedValues.Count > currentValueIndex)
                        {
                            matchesControlParam = false;
                            int targetValue = selectedValues[currentValueIndex];
                            
                            foreach (var condition in transition.conditions)
                            {
                                if (condition.parameter == selectedParameter && 
                                    Mathf.RoundToInt(condition.threshold) == targetValue)
                                {
                                    matchesControlParam = true;
                                    break;
                                }
                            }
                        }
                        
                        if (matchesControlParam && !gestureValueToStatesMap[gestureValue].Contains(transition.destinationState))
                        {
                            gestureValueToStatesMap[gestureValue].Add(transition.destinationState);
                        }
                    }
                }
            }
            
            // その他のステートからの遷移も検索
            foreach (var childState in stateMachine.states)
            {
                foreach (var transition in childState.state.transitions)
                {
                    if (transition.destinationState == null) continue;
                    
                    bool hasGestureCondition = false;
                    int gestureValue = -1;
                    
                    foreach (var condition in transition.conditions)
                    {
                        if (condition.parameter == gestureType)
                        {
                            hasGestureCondition = true;
                            gestureValue = Mathf.RoundToInt(condition.threshold);
                            break;
                        }
                    }
                    
                    if (hasGestureCondition && gestureValue >= 0 && gestureValue <= 7)
                    {
                        // コントロールパラメータのフィルタリング
                        bool matchesControlParam = true;
                        if (!string.IsNullOrEmpty(selectedParameter) && selectedValues.Count > currentValueIndex)
                        {
                            matchesControlParam = false;
                            int targetValue = selectedValues[currentValueIndex];
                            
                            foreach (var condition in transition.conditions)
                            {
                                if (condition.parameter == selectedParameter && 
                                    Mathf.RoundToInt(condition.threshold) == targetValue)
                                {
                                    matchesControlParam = true;
                                    break;
                                }
                            }
                        }
                        
                        if (matchesControlParam && !gestureValueToStatesMap[gestureValue].Contains(transition.destinationState))
                        {
                            gestureValueToStatesMap[gestureValue].Add(transition.destinationState);
                        }
                    }
                }
            }
            
            // 見つかったすべてのステートでVRC Avatar Parameter Driverを検索
            for (int gestureValue = 0; gestureValue < 8; gestureValue++)
            {
                foreach (var state in gestureValueToStatesMap[gestureValue])
                {
                    string statePath = $"{layerPath}/{state.name}";
                    
                    bool hasParamDriver = false;
                    foreach (var behaviour in state.behaviours)
                    {
                        if (behaviour == null)
                            continue;
                            
                        string typeName = behaviour.GetType().FullName;
                        
                        if (typeName == VRCParameterDriverTypeName || 
                            typeName.EndsWith("VRCAvatarParameterDriver") ||
                            typeName == ModularAvatarDriverTypeName || 
                            typeName.EndsWith("ParameterSyncStep"))
                        {
                            hasParamDriver = true;
                            var parameters = GetParametersFromDriver(behaviour);
                            
                            foreach (var paramState in parameters)
                            {
                                paramState.statePath = statePath;
                                paramState.gestureType = gestureType;
                                paramState.gestureValue = gestureValue;
                                paramState.behaviour = behaviour;
                                
                                // 重複を避ける（完全に同じパラメータの場合はスキップ）
                                if (!gestureParameterMap[gestureType].Any(p => 
                                    p.gestureValue == gestureValue && 
                                    p.parameterName == paramState.parameterName &&
                                    p.statePath == statePath &&
                                    Math.Abs(p.value - paramState.value) < 0.001f))
                                {
                                    gestureParameterMap[gestureType].Add(paramState);
                                    foundCount++;
                                }
                            }
                        }
                    }
                    
                    if (!hasParamDriver && showDebugInfo)
                    {
                        Debug.Log($"ジェスチャー条件付きステートが見つかりましたが、パラメータドライバーがありません: {statePath} ({gestureType}={gestureValue})");
                    }
                }
            }
            
            // サブステートマシンを探索
            foreach (var childStateMachine in stateMachine.stateMachines)
            {
                string subPath = $"{layerPath}/{childStateMachine.stateMachine.name}";
                foundCount += ExtensiveSearchForGestureTransitions(childStateMachine.stateMachine, subPath, gestureType);
            }
            
            return foundCount;
        }

        private void DrawParameterToggle(ParameterDriverState paramState)
        {
            EditorGUILayout.BeginHorizontal();
            
            GUILayout.Space(20); // インデント
            
            bool isEnabled = Math.Abs(paramState.value - 1.0f) < 0.001f;
            string buttonText = isEnabled ? "ON" : "OFF";
            GUIStyle currentStyle = isEnabled ? enabledStyle : disabledStyle;
            
            // パラメータ名
            EditorGUILayout.LabelField(paramState.parameterName, GUILayout.Width(150));
            
            // 値の表示
            EditorGUILayout.LabelField(paramState.value.ToString("F1"), GUILayout.Width(40));
            
            // トグルボタン
            if (GUILayout.Button(buttonText, currentStyle, GUILayout.Width(60)))
            {
                float newValue = isEnabled ? 0.0f : 1.0f;
                UpdateParameterValue(paramState, newValue);
            }
            
            // 削除ボタン
            if (GUILayout.Button("削除", GUILayout.Width(40)))
            {
                RemoveParameterFromState(paramState);
            }
            
            // ステートパスの表示
            if (showDebugInfo)
            {
                EditorGUILayout.LabelField(paramState.statePath, GUILayout.ExpandWidth(true));
            }
            else
            {
                // 最後のパスコンポーネントのみ表示
                string[] pathParts = paramState.statePath.Split('/');
                if (pathParts.Length > 0)
                {
                    EditorGUILayout.LabelField(pathParts[pathParts.Length - 1], GUILayout.ExpandWidth(true));
                }
            }
            
            EditorGUILayout.EndHorizontal();
        }

        private void ShowAddParameterMenu(string gestureType, int gestureValue)
        {
            // アニメーターから見つかったすべてのパラメータを表示するポップアップ
            var menu = new GenericMenu();
            
            // コントローラ内のすべてのパラメータを取得
            foreach (var param in targetController.parameters)
            {
                string parameter = param.name;
                
                // 既に存在するパラメータかどうか
                bool exists = gestureParameterMap[gestureType].Any(p => 
                    p.gestureValue == gestureValue && p.parameterName == parameter);
                
                menu.AddItem(new GUIContent(parameter), exists, () => {
                    AddParameterToGesture(gestureType, gestureValue, parameter);
                });
            }
            
            menu.ShowAsContext();
        }

        private void AddParameterToGesture(string gestureType, int gestureValue, string parameterName)
        {
            // 既存のパラメータをチェック
            var existingParam = gestureParameterMap[gestureType].FirstOrDefault(p => 
                p.gestureValue == gestureValue && p.parameterName == parameterName);
                
            if (existingParam != null)
            {
                // すでに存在する場合は値を更新
                UpdateParameterValue(existingParam, 1.0f);
                return;
            }
            
            // 対応するステートを検索
            var statesForGesture = gestureParameterMap[gestureType]
                .Where(p => p.gestureValue == gestureValue)
                .Select(p => p.statePath)
                .Distinct()
                .ToList();
                
            string targetStatePath = null;
            
            if (statesForGesture.Count > 0)
            {
                targetStatePath = statesForGesture[0];
            }
            else
            {
                // トランジションから見つける
                targetStatePath = FindGestureStatePathFromTransitions(gestureType, gestureValue);
            }
            
            if (string.IsNullOrEmpty(targetStatePath))
            {
                EditorUtility.DisplayDialog("エラー", $"{gestureType} {gestureValue}に対応するステートが見つかりませんでした。", "OK");
                return;
            }
            
            // ステートのVRC Avatar Parameter Driverを検索
            AnimatorState state = FindStateByPath(targetStatePath);
            if (state == null)
            {
                EditorUtility.DisplayDialog("エラー", $"ステート {targetStatePath} が見つかりませんでした。", "OK");
                return;
            }
            
            // パラメータを追加
            AddParameterToState(state, parameterName, 1.0f);
            
            // 再解析
            AnalyzeController();
        }

        private void RemoveParameterFromState(ParameterDriverState paramState)
        {
            if (paramState.behaviour == null)
                return;

            var serializedObj = new SerializedObject(paramState.behaviour);
            
            // パラメータプロパティを検索（VRChatとModularAvatarの両方をチェック）
            var parametersProp = serializedObj.FindProperty("parameters");
            
            if (parametersProp == null)
            {
                parametersProp = serializedObj.FindProperty("parameterDrivers");
            }
            
            if (parametersProp != null && parametersProp.isArray && paramState.propertyIndex < parametersProp.arraySize)
            {
                parametersProp.DeleteArrayElementAtIndex(paramState.propertyIndex);
                serializedObj.ApplyModifiedProperties();
                
                EditorUtility.SetDirty(paramState.behaviour);
                EditorUtility.SetDirty(targetController);
                
                Debug.Log($"[VRCFaceController] {paramState.gestureType} {paramState.gestureValue}({GestureNames[paramState.gestureValue]})の" +
                          $"パラメータ '{paramState.parameterName}' を削除しました");
                
                // 再解析
                AnalyzeController();
            }
        }

        private string FindGestureStatePathFromTransitions(string gestureType, int gestureValue)
        {
            // トランジションの条件からステートを検索
            foreach (var layer in targetController.layers)
            {
                // レイヤーフィルタリングを適用
                if (selectedLayerIndex >= 0 && layer != targetController.layers[selectedLayerIndex])
                    continue;
                    
                if (layer.stateMachine != null)
                {
                    // まずAnyStateトランジションをチェック
                    foreach (var transition in layer.stateMachine.anyStateTransitions)
                    {
                        if (transition.destinationState == null) continue;
                        
                        bool matchFound = false;
                        
                        foreach (var condition in transition.conditions)
                        {
                            if (condition.parameter == gestureType && 
                                Mathf.RoundToInt(condition.threshold) == gestureValue)
                            {
                                // コントロールパラメータのフィルタリングも適用
                                if (!string.IsNullOrEmpty(selectedParameter) && selectedValues.Count > currentValueIndex)
                                {
                                    bool hasMatchingCondition = false;
                                    foreach (var c in transition.conditions)
                                    {
                                        if (c.parameter == selectedParameter && 
                                            Mathf.RoundToInt(c.threshold) == selectedValues[currentValueIndex])
                                        {
                                            hasMatchingCondition = true;
                                            break;
                                        }
                                    }
                                    
                                    if (!hasMatchingCondition)
                                        continue;
                                }
                                
                                matchFound = true;
                                break;
                            }
                        }
                        
                        if (matchFound)
                        {
                            return $"{layer.name}/{transition.destinationState.name}";
                        }
                    }
                    
                    // エントリーステートからの遷移もチェック
                    if (layer.stateMachine.defaultState != null)
                    {
                        foreach (var transition in layer.stateMachine.defaultState.transitions)
                        {
                            if (transition.destinationState == null) continue;
                            
                            bool matchFound = false;
                            
                            foreach (var condition in transition.conditions)
                            {
                                if (condition.parameter == gestureType && 
                                    Mathf.RoundToInt(condition.threshold) == gestureValue)
                                {
                                    // コントロールパラメータのフィルタリングも適用
                                    if (!string.IsNullOrEmpty(selectedParameter) && selectedValues.Count > currentValueIndex)
                                    {
                                        bool hasMatchingCondition = false;
                                        foreach (var c in transition.conditions)
                                        {
                                            if (c.parameter == selectedParameter && 
                                                Mathf.RoundToInt(c.threshold) == selectedValues[currentValueIndex])
                                            {
                                                hasMatchingCondition = true;
                                                break;
                                            }
                                        }
                                        
                                        if (!hasMatchingCondition)
                                            continue;
                                    }
                                    
                                    matchFound = true;
                                    break;
                                }
                            }
                            
                            if (matchFound)
                            {
                                return $"{layer.name}/{transition.destinationState.name}";
                            }
                        }
                    }
                }
            }
            
            return null;
        }
        
        private AnimatorState FindStateByPath(string statePath)
        {
            // ステートへのパスからステートを検索
            string[] pathParts = statePath.Split('/');
            
            if (pathParts.Length < 2)
                return null;
                
            string layerName = pathParts[0];
            
            // レイヤーを検索
            AnimatorControllerLayer layer = null;
            foreach (var l in targetController.layers)
            {
                if (l.name == layerName)
                {
                    layer = l;
                    break;
                }
            }
            
            if (layer == null || layer.stateMachine == null)
                return null;
                
            // サブパスを再構築
            string subPath = string.Join("/", pathParts.Skip(1));
            
            return FindStateInStateMachine(layer.stateMachine, subPath);
        }
        
        private AnimatorState FindStateInStateMachine(AnimatorStateMachine stateMachine, string path)
        {
            string[] pathParts = path.Split('/');
            string currentName = pathParts[0];
            
            // 直接の子ステートを検索
            foreach (var childState in stateMachine.states)
            {
                if (childState.state.name == currentName)
                {
                    if (pathParts.Length == 1)
                        return childState.state;
                    else
                        return null; // パスの残りの部分はステートにはない
                }
            }
            
            // サブステートマシンを検索
            if (pathParts.Length > 1)
            {
                foreach (var childStateMachine in stateMachine.stateMachines)
                {
                    if (childStateMachine.stateMachine.name == currentName)
                    {
                        string subPath = string.Join("/", pathParts.Skip(1));
                        return FindStateInStateMachine(childStateMachine.stateMachine, subPath);
                    }
                }
            }
            
            return null;
        }
        
        private void AddParameterToState(AnimatorState state, string parameterName, float value)
        {
            // VRC Avatar Parameter Driverを検索
            StateMachineBehaviour driver = null;
            
            foreach (var behaviour in state.behaviours)
            {
                if (behaviour == null)
                    continue;
                    
                string typeName = behaviour.GetType().FullName;
                
                if (typeName == VRCParameterDriverTypeName || 
                    typeName.EndsWith("VRCAvatarParameterDriver") ||
                    typeName == ModularAvatarDriverTypeName || 
                    typeName.EndsWith("ParameterSyncStep"))
                {
                    driver = behaviour;
                    break;
                }
            }
            
            if (driver == null)
            {
                // ドライバーがない場合は追加
                try
                {
                    Type driverType = AppDomain.CurrentDomain.GetAssemblies()
                        .SelectMany(a => a.GetTypes())
                        .FirstOrDefault(t => t.FullName == VRCParameterDriverTypeName || t.Name == "VRCAvatarParameterDriver");
                        
                    if (driverType == null)
                    {
                        // ModularAvatarのParameterSyncStepも試す
                        driverType = AppDomain.CurrentDomain.GetAssemblies()
                            .SelectMany(a => a.GetTypes())
                            .FirstOrDefault(t => t.FullName == ModularAvatarDriverTypeName || t.Name == "ParameterSyncStep");
                            
                        if (driverType == null)
                        {
                            EditorUtility.DisplayDialog("エラー", "VRCAvatarParameterDriverとModularAvatarのParameterSyncStepが見つかりませんでした。VRChat SDKまたはModularAvatarがインポートされているか確認してください。", "OK");
                            return;
                        }
                    }
                    
                    driver = state.AddStateMachineBehaviour(driverType);
                    if (driver != null)
                    {
                        Undo.RegisterCreatedObjectUndo(driver, "Add VRC Avatar Parameter Driver");
                        EditorUtility.SetDirty(state);
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"パラメータドライバーの追加中にエラーが発生しました: {ex.Message}");
                    EditorUtility.DisplayDialog("エラー", $"パラメータドライバーの追加中にエラーが発生しました: {ex.Message}", "OK");
                    return;
                }
            }
            
            if (driver != null)
            {
                var serializedObj = new SerializedObject(driver);
                
                // パラメータプロパティを検索（VRChatとModularAvatarの両方をチェック）
                var parametersProp = serializedObj.FindProperty("parameters");
                
                if (parametersProp == null)
                {
                    parametersProp = serializedObj.FindProperty("parameterDrivers");
                }
                
                if (parametersProp == null)
                {
                    Debug.LogError("parametersプロパティが見つかりませんでした。");
                    return;
                }
                
                // 同名のパラメータがないか確認
                bool exists = false;
                for (int i = 0; i < parametersProp.arraySize; i++)
                {
                    var paramProp = parametersProp.GetArrayElementAtIndex(i);
                    var nameProp = paramProp.FindPropertyRelative("name");
                    
                    if (nameProp != null && nameProp.stringValue == parameterName)
                    {
                        // 既存のパラメータを更新
                        var valueProp = paramProp.FindPropertyRelative("value");
                        if (valueProp != null)
                        {
                            valueProp.floatValue = value;
                            exists = true;
                            break;
                        }
                    }
                }
                
                if (!exists)
                {
                    // 新しいパラメータを追加
                    parametersProp.arraySize++;
                    var newParamProp = parametersProp.GetArrayElementAtIndex(parametersProp.arraySize - 1);
                    
                    var nameProp = newParamProp.FindPropertyRelative("name");
                    var valueProp = newParamProp.FindPropertyRelative("value");
                    var typeProp = newParamProp.FindPropertyRelative("type");
                    
                    if (nameProp != null && valueProp != null)
                    {
                        nameProp.stringValue = parameterName;
                        valueProp.floatValue = value;
                        
                        // タイプがある場合はセット
                        if (typeProp != null)
                        {
                            // 0 = Set (VRCSDKの場合)
                            typeProp.intValue = 0;
                        }
                    }
                }
                
                serializedObj.ApplyModifiedProperties();
                EditorUtility.SetDirty(driver);
                EditorUtility.SetDirty(state);
                EditorUtility.SetDirty(targetController);
                
                Debug.Log($"パラメータ '{parameterName}' ({value}) を '{state.name}' に追加しました");
            }
        }

        #endregion

        #region タブ2: アニメーション置換

        private void DrawAnimationReplaceTab()
        {
            EditorGUILayout.BeginVertical();
            
            EditorGUILayout.LabelField("アニメーション置換", EditorStyles.boldLabel);
            DrawThinSeparator();
            
            // 出力設定
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            EditorGUILayout.LabelField("出力設定", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("出力フォルダ:", GUILayout.Width(100));
            outputFolder = EditorGUILayout.TextField(outputFolder);
            
            if (GUILayout.Button("参照", GUILayout.Width(60)))
            {
                string folder = EditorUtility.SaveFolderPanel("出力先フォルダ", "Assets", "");
                if (!string.IsNullOrEmpty(folder))
                {
                    // プロジェクトパスに変換
                    if (folder.StartsWith(Application.dataPath))
                    {
                        folder = "Assets" + folder.Substring(Application.dataPath.Length);
                        outputFolder = folder;
                    }
                }
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("出力プレフィックス:", GUILayout.Width(100));
            outputPrefix = EditorGUILayout.TextField(outputPrefix);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("コントローラ複製:", GUILayout.Width(100));
            copyController = EditorGUILayout.Toggle(copyController);
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.Space(10);
            
            // コントローラのアニメーションがない場合はメッセージを表示して終了
            if (controllerClips.Count == 0)
            {
                EditorGUILayout.HelpBox("アニメーターコントローラからアニメーションが見つかりませんでした。", MessageType.Info);
                
                if (GUILayout.Button("アニメーションを検索", GUILayout.Height(30)))
                {
                    FindAnimationsInController();
                }
                
                EditorGUILayout.EndVertical();
                return;
            }
            
            // 置換マップの表示
            EditorGUILayout.LabelField("置換マップ", EditorStyles.boldLabel);
            
            animScrollPosition = EditorGUILayout.BeginScrollView(animScrollPosition, GUILayout.Height(300));
            
            // コントローラ内の各アニメーションとそれを置き換えるアニメーションを表示
            for (int i = 0; i < controllerClips.Count; i++)
            {
                DrawAnimationReplaceRow(controllerClips[i]);
            }
            
            EditorGUILayout.EndScrollView();
            
            EditorGUILayout.Space(5);
            
            // 置換の実行ボタン
            if (animationReplacementMap.Count > 0)
            {
                if (GUILayout.Button("アニメーションを置換", GUILayout.Height(30)))
                {
                    ReplaceAnimations();
                }
            }
            
            EditorGUILayout.EndVertical();
        }
        
        private void FindAnimationsInController()
        {
            controllerClips.Clear();
            animationReplacementMap.Clear();
            
            foreach (var layer in targetController.layers)
            {
                if (layer.stateMachine != null)
                {
                    CollectAnimationClips(layer.stateMachine);
                }
            }
            
            // 重複を削除してソート
            controllerClips = controllerClips.Distinct().OrderBy(c => c.name).ToList();
            
            if (controllerClips.Count == 0)
            {
                EditorUtility.DisplayDialog("検索結果", "アニメーションクリップが見つかりませんでした。", "OK");
            }
            else
            {
                EditorUtility.DisplayDialog("検索完了", $"{controllerClips.Count}個のアニメーションクリップを見つけました。", "OK");
            }
        }
        
        private void DrawAnimationReplaceRow(AnimationClip controllerClip)
        {
            if (controllerClip == null)
                return;
                
            EditorGUILayout.BeginHorizontal(EditorStyles.helpBox);
            
            // コントローラのアニメーション
            EditorGUILayout.ObjectField(controllerClip, typeof(AnimationClip), false, GUILayout.Width(200));
            
            EditorGUILayout.LabelField("→", GUILayout.Width(20));
            
            // 置換先のアニメーション
            AnimationClip replacementClip = null;
            if (animationReplacementMap.ContainsKey(controllerClip))
            {
                replacementClip = animationReplacementMap[controllerClip];
            }
            
            EditorGUI.BeginChangeCheck();
            replacementClip = (AnimationClip)EditorGUILayout.ObjectField(replacementClip, typeof(AnimationClip), false, GUILayout.Width(200));
            
            if (EditorGUI.EndChangeCheck())
            {
                if (replacementClip != null)
                {
                    animationReplacementMap[controllerClip] = replacementClip;
                }
                else if (animationReplacementMap.ContainsKey(controllerClip))
                {
                    animationReplacementMap.Remove(controllerClip);
                }
            }
            
            // クリアボタン
            if (animationReplacementMap.ContainsKey(controllerClip) && GUILayout.Button("クリア", GUILayout.Width(60)))
            {
                animationReplacementMap.Remove(controllerClip);
            }
            
            EditorGUILayout.EndHorizontal();
        }
        
        private void ReplaceAnimations()
        {
            if (targetController == null || animationReplacementMap.Count == 0)
                return;
                
            // 出力フォルダの確認
            if (!AssetDatabase.IsValidFolder(outputFolder))
            {
                try
                {
                    string[] folderParts = outputFolder.Split('/');
                    string currentPath = folderParts[0];
                    
                    for (int i = 1; i < folderParts.Length; i++)
                    {
                        string parentFolder = currentPath;
                        currentPath = Path.Combine(currentPath, folderParts[i]);
                        
                        if (!AssetDatabase.IsValidFolder(currentPath))
                        {
                            AssetDatabase.CreateFolder(parentFolder, folderParts[i]);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"フォルダの作成中にエラーが発生しました: {ex.Message}");
                    EditorUtility.DisplayDialog("エラー", $"フォルダの作成中にエラーが発生しました: {ex.Message}", "OK");
                    return;
                }
            }
            
            AnimatorController controller = targetController;
            
            if (copyController)
            {
                // コントローラの複製
                string sourcePath = AssetDatabase.GetAssetPath(targetController);
                string defaultName = Path.GetFileNameWithoutExtension(sourcePath);
                string destinationPath = Path.Combine(outputFolder, $"{outputPrefix}{defaultName}.controller");
                
                if (File.Exists(destinationPath))
                {
                    int counter = 1;
                    while (File.Exists(Path.Combine(outputFolder, $"{outputPrefix}{defaultName}_{counter}.controller")))
                    {
                        counter++;
                    }
                    destinationPath = Path.Combine(outputFolder, $"{outputPrefix}{defaultName}_{counter}.controller");
                }
                
                try
                {
                    AssetDatabase.CopyAsset(sourcePath, destinationPath);
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                    
                    controller = AssetDatabase.LoadAssetAtPath<AnimatorController>(destinationPath);
                    if (controller == null)
                    {
                        EditorUtility.DisplayDialog("エラー", "コントローラの複製に失敗しました。", "OK");
                        return;
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"コントローラの複製中にエラーが発生しました: {ex.Message}");
                    EditorUtility.DisplayDialog("エラー", $"コントローラの複製中にエラーが発生しました: {ex.Message}", "OK");
                    return;
                }
            }
            
            int replacedCount = 0;
            
            // アニメーションの置換
            foreach (var layer in controller.layers)
            {
                if (layer.stateMachine != null)
                {
                    replacedCount += ReplaceAnimationsInStateMachine(layer.stateMachine);
                }
            }
            
            if (replacedCount > 0)
            {
                EditorUtility.SetDirty(controller);
                AssetDatabase.SaveAssets();
                AssetDatabase.Refresh();
                
                string message = $"{replacedCount}個のアニメーションを置換しました。";
                if (copyController)
                {
                    message += $"\n\n新しいコントローラ: {controller.name}";
                }
                
                EditorUtility.DisplayDialog("置換完了", message, "OK");
                
                // 新しいコントローラを選択
                Selection.activeObject = controller;
                
                // 再解析
                if (controller == targetController)
                {
                    AnalyzeController();
                }
            }
            else
            {
                if (copyController)
                {
                    // 空のコントローラを削除
                    string path = AssetDatabase.GetAssetPath(controller);
                    AssetDatabase.DeleteAsset(path);
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }
                
                EditorUtility.DisplayDialog("置換", "置換するアニメーションが見つかりませんでした。", "OK");
            }
        }
        
        private int ReplaceAnimationsInStateMachine(AnimatorStateMachine stateMachine)
        {
            int replacedCount = 0;
            
            // ステート内のアニメーションを置換
            foreach (var childState in stateMachine.states)
            {
                AnimatorState state = childState.state;
                
                if (state.motion is AnimationClip clip && animationReplacementMap.ContainsKey(clip))
                {
                    state.motion = animationReplacementMap[clip];
                    EditorUtility.SetDirty(state);
                    replacedCount++;
                }
                else if (state.motion is BlendTree blendTree)
                {
                    replacedCount += ReplaceAnimationsInBlendTree(blendTree);
                }
            }
            
            // サブステートマシンの探索
            foreach (var childStateMachine in stateMachine.stateMachines)
            {
                replacedCount += ReplaceAnimationsInStateMachine(childStateMachine.stateMachine);
            }
            
            return replacedCount;
        }
        
        private int ReplaceAnimationsInBlendTree(BlendTree blendTree)
        {
            int replacedCount = 0;
            
            var children = blendTree.children;
            bool hasChanges = false;
            
            for (int i = 0; i < children.Length; i++)
            {
                var child = children[i];
                
                if (child.motion is AnimationClip clip && animationReplacementMap.ContainsKey(clip))
                {
                    child.motion = animationReplacementMap[clip];
                    children[i] = child;
                    hasChanges = true;
                    replacedCount++;
                }
                else if (child.motion is BlendTree childTree)
                {
                    replacedCount += ReplaceAnimationsInBlendTree(childTree);
                }
            }
            
            if (hasChanges)
            {
                blendTree.children = children;
                EditorUtility.SetDirty(blendTree);
            }
            
            return replacedCount;
        }

        #endregion

        #region タブ3: 設定

        private void DrawSettingsTab()
        {
            EditorGUILayout.BeginVertical();
            
            EditorGUILayout.LabelField("コントローラ操作", EditorStyles.boldLabel);
            DrawThinSeparator();
            
            // アニメーターコントローラ操作
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("出力フォルダ:", GUILayout.Width(100));
            outputFolder = EditorGUILayout.TextField(outputFolder);
            
            if (GUILayout.Button("参照", GUILayout.Width(60)))
            {
                string folder = EditorUtility.SaveFolderPanel("出力先フォルダ", "Assets", "");
                if (!string.IsNullOrEmpty(folder))
                {
                    // プロジェクトパスに変換
                    if (folder.StartsWith(Application.dataPath))
                    {
                        folder = "Assets" + folder.Substring(Application.dataPath.Length);
                        outputFolder = folder;
                    }
                }
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("出力プレフィックス:", GUILayout.Width(100));
            outputPrefix = EditorGUILayout.TextField(outputPrefix);
            EditorGUILayout.EndHorizontal();
            
            if (GUILayout.Button("現在のコントローラを複製", GUILayout.Height(30)))
            {
                DuplicateController();
            }
            
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.Space(10);
            
            // 使い方
            EditorGUILayout.LabelField("ツールの使い方", EditorStyles.boldLabel);
            DrawThinSeparator();
            
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            EditorGUILayout.HelpBox(
                "このツールの使い方:\n\n" +
                "1. アニメーターコントローラを選択またはドラッグ＆ドロップします\n" +
                "2. レイヤーとパラメータを選択して表示するステートを絞り込みます\n" +
                "  （パラメータは「なし」でも動作します）\n" +
                "3. 各ジェスチャーのパラメータをON/OFFで切り替えます\n" +
                "4. 「変更を保存」ボタンで変更を保存します\n\n" +
                "アニメーション置換タブでは、コントローラ内のアニメーションを置き換えることができます。\n" +
                "設定タブでは、コントローラの複製や表示オプションが変更できます。",
                MessageType.Info);
            
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.EndVertical();
        }
        
        private void DuplicateController()
        {
            if (targetController == null)
            {
                EditorUtility.DisplayDialog("エラー", "アニメーターコントローラが選択されていません。", "OK");
                return;
            }
            
            // 出力フォルダの確認
            if (!AssetDatabase.IsValidFolder(outputFolder))
            {
                try
                {
                    string[] folderParts = outputFolder.Split('/');
                    string currentPath = folderParts[0];
                    
                    for (int i = 1; i < folderParts.Length; i++)
                    {
                        string parentFolder = currentPath;
                        currentPath = Path.Combine(currentPath, folderParts[i]);
                        
                        if (!AssetDatabase.IsValidFolder(currentPath))
                        {
                            AssetDatabase.CreateFolder(parentFolder, folderParts[i]);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"フォルダの作成中にエラーが発生しました: {ex.Message}");
                    EditorUtility.DisplayDialog("エラー", $"フォルダの作成中にエラーが発生しました: {ex.Message}", "OK");
                    return;
                }
            }
            
            // コントローラの複製
            string sourcePath = AssetDatabase.GetAssetPath(targetController);
            string defaultName = Path.GetFileNameWithoutExtension(sourcePath);
            string destinationPath = Path.Combine(outputFolder, $"{outputPrefix}{defaultName}.controller");
            
            if (File.Exists(destinationPath))
            {
                int counter = 1;
                while (File.Exists(Path.Combine(outputFolder, $"{outputPrefix}{defaultName}_{counter}.controller")))
                {
                    counter++;
                }
                destinationPath = Path.Combine(outputFolder, $"{outputPrefix}{defaultName}_{counter}.controller");
            }
            
            try
            {
                AssetDatabase.CopyAsset(sourcePath, destinationPath);
                AssetDatabase.SaveAssets();
                AssetDatabase.Refresh();
                
                AnimatorController newController = AssetDatabase.LoadAssetAtPath<AnimatorController>(destinationPath);
                if (newController != null)
                {
                    targetController = newController;
                    AnalyzeController();
                    
                    EditorUtility.DisplayDialog("複製完了", $"コントローラを複製しました: {destinationPath}", "OK");
                    
                    // 新しいコントローラを選択
                    Selection.activeObject = newController;
                }
                else
                {
                    EditorUtility.DisplayDialog("エラー", "コントローラの複製に失敗しました。", "OK");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"コントローラの複製中にエラーが発生しました: {ex.Message}");
                EditorUtility.DisplayDialog("エラー", $"コントローラの複製中にエラーが発生しました: {ex.Message}", "OK");
            }
        }

        #endregion

        #region ユーティリティメソッド

        private void DrawControllerSelectionArea()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("アニメーターコントローラ", EditorStyles.boldLabel, GUILayout.Width(150));
            
            EditorGUI.BeginChangeCheck();
            targetController = (AnimatorController)EditorGUILayout.ObjectField(
                targetController, typeof(AnimatorController), false, GUILayout.ExpandWidth(true));
            
            if (EditorGUI.EndChangeCheck() && targetController != null)
            {
                AnalyzeController();
            }
            
            EditorGUILayout.EndHorizontal();

            // ドラッグ＆ドロップエリア
            Rect dropArea = GUILayoutUtility.GetRect(0.0f, 40.0f, GUILayout.Width(position.width - 20), GUILayout.MaxWidth(position.width - 20));
            dropArea.x += 10;
            GUI.Box(dropArea, "", dropAreaStyle);
            EditorGUI.LabelField(dropArea, "AnimatorControllerをここにドラッグ＆ドロップ", dropAreaTextStyle);
            HandleDragAndDrop(dropArea);
            
            EditorGUILayout.EndVertical();
        }

        private void HandleDragAndDrop(Rect dropArea)
        {
            Event evt = Event.current;
            
            if (!dropArea.Contains(evt.mousePosition))
                return;
                
            switch (evt.type)
            {
                case EventType.DragUpdated:
                    bool hasAnimatorController = DragAndDrop.objectReferences
                        .Any(obj => obj is AnimatorController);
                        
                    DragAndDrop.visualMode = hasAnimatorController ? 
                        DragAndDropVisualMode.Copy : DragAndDropVisualMode.Rejected;
                        
                    evt.Use();
                    break;
                case EventType.DragPerform:
                    DragAndDrop.AcceptDrag();
                    
                    foreach (UnityEngine.Object draggedObject in DragAndDrop.objectReferences)
                    {
                        if (draggedObject is AnimatorController)
                        {
                            targetController = draggedObject as AnimatorController;
                            AnalyzeController();
                            break;
                        }
                    }
                    
                    evt.Use();
                    break;
            }
        }

        private void AnalyzeController()
        {
            if (targetController == null)
                return;

            // まず状態をクリア
            gestureParameterMap.Clear();
            gestureParameterMap["GestureLeft"] = new List<ParameterDriverState>();
            gestureParameterMap["GestureRight"] = new List<ParameterDriverState>();
            
            // レイヤー名リストの更新
            layerNames = targetController.layers.Select(l => l.name).ToArray();
            
            // パラメータリストの更新
            availableParameters.Clear();
            parameterValues.Clear();
            
            // コントローラのパラメータの追加
            foreach (var parameter in targetController.parameters)
            {
                if (!availableParameters.Contains(parameter.name) && !string.IsNullOrEmpty(parameter.name))
                {
                    availableParameters.Add(parameter.name);
                    parameterValues[parameter.name] = parameter.defaultFloat;
                }
            }
            
            // コントロールパラメータを並び替え
            List<string> sortedParameters = new List<string>();
            
            // F_Setなどのコントロールパラメータを優先的に表示
            var controlParams = availableParameters.Where(p => 
                p.StartsWith("F_") || p.EndsWith("_set") || p.Contains("Set") || p.Contains("set")).ToList();
                
            sortedParameters.AddRange(controlParams);
            
            // その他のパラメータを追加
            var otherParams = availableParameters.Except(controlParams).ToList();
            sortedParameters.AddRange(otherParams);
            
            availableParameters = sortedParameters;
            
            // フィルタ値の設定
            UpdateParameterValueOptions();

            // 選択されたレイヤーだけをフィルタリング
            List<AnimatorControllerLayer> targetLayers = new List<AnimatorControllerLayer>();
            if (selectedLayerIndex >= 0 && selectedLayerIndex < targetController.layers.Length)
            {
                // 特定のレイヤーだけを処理
                targetLayers.Add(targetController.layers[selectedLayerIndex]);
            }
            else
            {
                // すべてのレイヤーを処理
                targetLayers.AddRange(targetController.layers);
            }

            // 選択されたレイヤーでトランジション条件からステートを検出
            foreach (var layer in targetLayers)
            {
                if (layer.stateMachine != null)
                {
                    // 左右の手のジェスチャー検出
                    ExtensiveSearchForGestureTransitions(layer.stateMachine, layer.name, "GestureLeft");
                    ExtensiveSearchForGestureTransitions(layer.stateMachine, layer.name, "GestureRight");
                }
            }
            
            // コントロールパラメータによるフィルタリングはExtensiveSearchForGestureTransitionsの中で行う
            
            // コントローラ内のアニメーションクリップを検索
            controllerClips.Clear();
            animationReplacementMap.Clear();
            
            foreach (var layer in targetController.layers)
            {
                if (layer.stateMachine != null)
                {
                    CollectAnimationClips(layer.stateMachine);
                }
            }
            
            // 重複を削除してソート
            controllerClips = controllerClips.Distinct().OrderBy(c => c.name).ToList();

            // デバッグ情報を更新
            if (showDebugInfo)
            {
                UpdateDebugInfo();
            }
            
            Debug.Log($"[VRCFaceController] 解析完了 - 左手: {gestureParameterMap["GestureLeft"].Count}件, 右手: {gestureParameterMap["GestureRight"].Count}件のパラメータを検出");
        }
        
        private void UpdateDebugInfo()
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            
            sb.AppendLine($"コントローラ: {(targetController ? targetController.name : "なし")}");
            sb.AppendLine($"レイヤー: {(selectedLayerIndex >= 0 && selectedLayerIndex < layerNames.Length ? layerNames[selectedLayerIndex] : "すべて")}");
            sb.AppendLine($"パラメータ数: {availableParameters.Count}");
            if (availableParameters.Count > 0)
            {
                sb.AppendLine("パラメータ一覧:");
                foreach (var param in availableParameters)
                {
                    sb.AppendLine($"  - {param}");
                }
            }
            
            sb.AppendLine($"選択パラメータ: {(string.IsNullOrEmpty(selectedParameter) ? "なし" : selectedParameter)}, " +
                           $"値: {(selectedValues.Count > 0 && currentValueIndex < selectedValues.Count ? selectedValues[currentValueIndex] : -1)}");
            
            sb.AppendLine($"GestureLeft パラメータ: {gestureParameterMap["GestureLeft"].Count}件");
            sb.AppendLine($"GestureRight パラメータ: {gestureParameterMap["GestureRight"].Count}件");
            
            if (gestureParameterMap["GestureLeft"].Count > 0 || gestureParameterMap["GestureRight"].Count > 0)
            {
                sb.AppendLine("ジェスチャーパラメータ一覧:");
                foreach (var gestureType in gestureParameterMap.Keys)
                {
                    foreach (var state in gestureParameterMap[gestureType])
                    {
                        sb.AppendLine($"  - {gestureType} {state.gestureValue}: {state.parameterName} = {state.value} ({state.statePath})");
                    }
                }
            }
            
            debugMessage = sb.ToString();
        }
        
        private void UpdateParameterValueOptions()
        {
            // 選択パラメータに基づいて値の選択肢を更新
            selectedValues.Clear();
            valueLabels.Clear();
            
            if (string.IsNullOrEmpty(selectedParameter))
            {
                // パラメータが選択されていない場合はデフォルト値
                selectedValues.Add(0);
                valueLabels.Add("値=0");
                currentValueIndex = 0;
                return;
            }
            
            // 実際に使用されている値を検索
            HashSet<int> usedValues = new HashSet<int>();
            
            // F_Setなどのコントロールパラメータの場合
            if (selectedParameter.StartsWith("F_") || selectedParameter.EndsWith("_set") || 
                selectedParameter.Contains("Set") || selectedParameter.Contains("set"))
            {
                // アニメーターの全レイヤーをチェック
                foreach (var layer in targetController.layers)
                {
                    if (layer.stateMachine != null)
                    {
                        // ステートマシン内のトランジション条件をチェック
                        CollectUsedParameterValues(layer.stateMachine, layer.name, selectedParameter, usedValues);
                    }
                }
                
                // 値が見つからなかった場合はデフォルト値を使用
                if (usedValues.Count == 0)
                {
                    usedValues.Add(0);
                    usedValues.Add(1);
                }
            }
            else
            {
                // その他のパラメータはON/OFFとして扱う
                usedValues.Add(0);
                usedValues.Add(1);
            }
            
            // 値の選択肢を作成（ソートして表示）
            var sortedValues = usedValues.ToList();
            sortedValues.Sort();
            
            foreach (int value in sortedValues)
            {
                selectedValues.Add(value);
                valueLabels.Add($"値={value}");
            }
            
            // インデックスの修正
            if (currentValueIndex >= valueLabels.Count)
            {
                currentValueIndex = 0;
            }
        }
        
        private void CollectUsedParameterValues(AnimatorStateMachine stateMachine, string path, string paramName, HashSet<int> usedValues)
        {
            // AnyStateトランジションをチェック
            foreach (var transition in stateMachine.anyStateTransitions)
            {
                foreach (var condition in transition.conditions)
                {
                    if (condition.parameter == paramName)
                    {
                        usedValues.Add(Mathf.RoundToInt(condition.threshold));
                    }
                }
            }
            
            // 通常のステートトランジションをチェック
            foreach (var childState in stateMachine.states)
            {
                foreach (var transition in childState.state.transitions)
                {
                    foreach (var condition in transition.conditions)
                    {
                        if (condition.parameter == paramName)
                        {
                            usedValues.Add(Mathf.RoundToInt(condition.threshold));
                        }
                    }
                }
            }
            
            // サブステートマシンを探索
            foreach (var childStateMachine in stateMachine.stateMachines)
            {
                string subPath = $"{path}/{childStateMachine.stateMachine.name}";
                CollectUsedParameterValues(childStateMachine.stateMachine, subPath, paramName, usedValues);
            }
        }
        
        private void CollectAnimationClips(AnimatorStateMachine stateMachine)
        {
            // ステートからアニメーションクリップを収集
            foreach (var childState in stateMachine.states)
            {
                if (childState.state.motion is AnimationClip clip)
                {
                    controllerClips.Add(clip);
                }
                else if (childState.state.motion is BlendTree blendTree)
                {
                    CollectAnimationClipsFromBlendTree(blendTree);
                }
            }
            
            // サブステートマシンの探索
            foreach (var childStateMachine in stateMachine.stateMachines)
            {
                CollectAnimationClips(childStateMachine.stateMachine);
            }
        }
        
        private void CollectAnimationClipsFromBlendTree(BlendTree blendTree)
        {
            foreach (var child in blendTree.children)
            {
                if (child.motion is AnimationClip clip)
                {
                    controllerClips.Add(clip);
                }
                else if (child.motion is BlendTree childTree)
                {
                    CollectAnimationClipsFromBlendTree(childTree);
                }
            }
        }

        private List<ParameterDriverState> GetParametersFromDriver(StateMachineBehaviour driver)
        {
            var result = new List<ParameterDriverState>();
            
            var serializedDriver = new SerializedObject(driver);
            
            // VRChatとModularAvatarで異なるプロパティ名をチェック
            var parametersProp = serializedDriver.FindProperty("parameters");
            
            if (parametersProp == null)
            {
                // ModularAvatarの場合は別のプロパティ名
                parametersProp = serializedDriver.FindProperty("parameterDrivers");
            }
            
            if (parametersProp != null && parametersProp.isArray)
            {
                for (int i = 0; i < parametersProp.arraySize; i++)
                {
                    var paramProp = parametersProp.GetArrayElementAtIndex(i);
                    var nameProp = paramProp.FindPropertyRelative("name");
                    var valueProp = paramProp.FindPropertyRelative("value");
                    
                    if (nameProp != null && valueProp != null)
                    {
                        result.Add(new ParameterDriverState
                        {
                            parameterName = nameProp.stringValue,
                            value = valueProp.floatValue,
                            propertyIndex = i,
                            serializedProperty = paramProp,
                            behaviour = driver
                        });
                    }
                }
            }
            
            return result;
        }

        private void UpdateParameterValue(ParameterDriverState paramState, float newValue)
        {
            if (paramState.behaviour == null)
                return;

            var serializedObj = new SerializedObject(paramState.behaviour);
            
            // パラメータプロパティを検索（VRChatとModularAvatarの両方をチェック）
            var parametersProp = serializedObj.FindProperty("parameters");
            
            if (parametersProp == null)
            {
                parametersProp = serializedObj.FindProperty("parameterDrivers");
            }
            
            if (parametersProp != null && parametersProp.isArray && paramState.propertyIndex < parametersProp.arraySize)
            {
                var paramProp = parametersProp.GetArrayElementAtIndex(paramState.propertyIndex);
                var valueProp = paramProp.FindPropertyRelative("value");
                
                if (valueProp != null)
                {
                    valueProp.floatValue = newValue;
                    serializedObj.ApplyModifiedProperties();
                    paramState.value = newValue;
                    
                    EditorUtility.SetDirty(paramState.behaviour);
                    EditorUtility.SetDirty(targetController);
                    
                    Debug.Log($"[VRCFaceController] {paramState.gestureType} {paramState.gestureValue}({GestureNames[paramState.gestureValue]})の" +
                              $"パラメータ '{paramState.parameterName}' を {newValue} に更新しました");
                }
            }
        }

        private void SaveAsset()
        {
            if (targetController == null)
                return;

            EditorUtility.SetDirty(targetController);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            
            EditorUtility.DisplayDialog("保存完了", "アニメーターコントローラに変更を保存しました。", "OK");
        }

        private Texture2D CreateColorTexture(Color color)
        {
            Texture2D texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            return texture;
        }

        #endregion
    }

    // VRC Avatar Parameter Driverの状態情報
    public class ParameterDriverState
    {
        public string parameterName;
        public float value;
        public string statePath;
        public string gestureType; // GestureLeft or GestureRight
        public int gestureValue;   // 0-7
        public StateMachineBehaviour behaviour;
        public SerializedProperty serializedProperty;
        public int propertyIndex;
    }

    // ジェスチャー情報
    public class GestureStateInfo
    {
        public string gestureType; // GestureLeft or GestureRight
        public int gestureValue;   // 0-7
    }
}
